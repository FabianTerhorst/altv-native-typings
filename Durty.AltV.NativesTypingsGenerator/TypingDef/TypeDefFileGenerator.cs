using System;
using System.Linq;
using Durty.AltV.NativesTypingsGenerator.Models.Typing;

namespace Durty.AltV.NativesTypingsGenerator.TypingDef
{
    public class TypeDefFileGenerator
    {
        private readonly TypeDef _typeDefFile;
        private readonly bool _generateDocumentation;

        public TypeDefFileGenerator(
            TypeDef typeDefFile,
            bool generateDocumentation = true)
        {
            _typeDefFile = typeDefFile;
            _generateDocumentation = generateDocumentation;
        }

        public string Generate(bool generateHeader = true)
        {
            string fileContent = "";
            if (generateHeader)
            {
                // THIS FILE IS AUTOGENERATED
                // Generated on "11/15/2019, 10:14:03 PM"
                fileContent += $"// THIS FILE IS AUTOGENERATED by Durty AltV NativeDB Typings Generator\n// Generated {DateTime.Now.ToShortDateString()} {DateTime.Now.ToShortTimeString()}\n\n";
            }
            fileContent += _typeDefFile.Interfaces.Aggregate("", (current, typeDefInterface) => current + GenerateInterface(typeDefInterface) + "\n");
            fileContent += "\n";

            fileContent += _typeDefFile.Types.Aggregate("", (current, typeDefType) => current + GenerateType(typeDefType) + "\n");
            fileContent += "\n";

            foreach (TypeDefModule typeDefModule in _typeDefFile.Modules)
            {
                fileContent += GenerateModule(typeDefModule);
                fileContent += "\n";
            }

            return fileContent;
        }

        private string GenerateInterface(TypeDefInterface typeDefInterface)
        {
            string result = $"interface {typeDefInterface.Name} {{\n";
            result = typeDefInterface.Properties.Aggregate(result, (current, property) => current + $"  {property.Name}: {property.Type};\n");
            result += "}";
            return result;
        }

        private string GenerateType(TypeDefType typeDefType)
        {
            return $"type {typeDefType.Name} = {typeDefType.TargetTypeName};";
        }

        private string GenerateModule(TypeDefModule typeDefModule)
        {
            string result = "";
            result += $"declare module \"{typeDefModule.Name}\" {{\n";
            result = typeDefModule.Functions.Aggregate(result, (current, typeDefFunction) => current + $"{GenerateFunction(typeDefFunction)}\n");
            result += "}";
            return result;
        }

        private string GenerateFunction(TypeDefFunction typeDefFunction)
        {
            string result = string.Empty;
            if (_generateDocumentation)
            {
                result += $"{GenerateFunctionDocumentation(typeDefFunction)}";
            }
            result += $"\texport function {typeDefFunction.Name}(";
            foreach (var parameter in typeDefFunction.Parameters)
            {
                result += $"{parameter.Name}: {parameter.Type}";
                if (typeDefFunction.Parameters.Last() != parameter)
                {
                    result += ", ";
                }
            }
            result += $"): {typeDefFunction.ReturnType.Name};";

            return result;
        }

        private string GenerateFunctionDocumentation(TypeDefFunction typeDefFunction)
        {
            //When no docs exist
            if (string.IsNullOrEmpty(typeDefFunction.Description) && typeDefFunction.Parameters.All(p => string.IsNullOrEmpty(p.Description) && string.IsNullOrEmpty(typeDefFunction.ReturnType.Description)))
                return string.Empty;

            string result = $"\t/**\n";
            if (!string.IsNullOrEmpty(typeDefFunction.Description))
            {
                string[] descriptionLines = typeDefFunction.Description.Split("\n");
                foreach (string descriptionLine in descriptionLines.Take(10)) //Docs summary can only show max 10 lines, will be cut afterwards anyway
                {
                    string sanitizedDescriptionLine = descriptionLine.Replace("/*", string.Empty).Replace("*/", string.Empty);
                    result += $"\t* {sanitizedDescriptionLine}\n";
                }
            }
            //TODO: add reference link (nativedb url)
            //Add @remarks in the future?
            //TODO: Add intelligent parameter description resolving (pattern matchin paraname - description)
            foreach (var parameter in typeDefFunction.Parameters)
            {
                if (!string.IsNullOrEmpty(parameter.Description))
                {
                    result += $"\t* @param {parameter.Name} {parameter.Description}\n";
                }
            }
            if (!string.IsNullOrEmpty(typeDefFunction.ReturnType.Description))
            {
                result += $"\t* {typeDefFunction.ReturnType.Description}\n";
            }
            result += "\t*/\n";
            return result;
        }
    }
}
